#
# (C) Copyright IBM Corp. 2017
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#' @include ml.model.base.R
#' @include zzz.R
#' 
# This class represents a ALS model for factorization.
setClass("r4ml.als",
         representation(
           leftFactor = "SparkDataFrame",
           rightFactor = "SparkDataFrame"
         ), contains = "r4ml.model"
)

#' Alternating Least Squares
#'
#' Performs matrix factorization using the Alternating Least Squares algorithm.
#' Two factor matrices, namely L and R are generated by r4ml.als.
#' @param data (r4ml.matrix) a r4ml.matrix to be factorized
#' @param rank (numeric) the rank of the factorization. This value should be much smaller than 
#' the number of rows and columns of the dataset.
#' @param reg.type (character) regularization type. Supported types are "L2" or "wL2". Default is "L2".
#' @param lambda (numeric) regularization parameter
#' @param iter.max (numeric) maximum number of iterations
#' @param tolerance (numeric) convergence parameter. Measures the decrease in loss between consecutive
#' iterations - if the decrease is below this threshold the algorithm will stop.
#' @return an S4 object of class \code{r4ml.als} which contains the arguments above as well as the additional fields:
#' 
#'  \tabular{rlll}{
##'   \tab\code{L}   \tab (character) \tab left factor matrix\cr
##'   \tab\code{Rt}  \tab (character) \tab right factor matrix\cr
##'   \tab\code{call}         \tab (character) \tab String representation of this method's call, including the parameters and values passed to it.\cr
#'  }  
#'  
#' @details ALS is used to calculate the best factor matrices L and R for the given input matrix. It considers different
#' user-specified regularization parameters and weights.
#' 
#' @examples \dontrun{
#' 
#' # Create a sample dataset: 4 items, 2 users
#' df <- data.frame(X1=c(1, 0), X2=c(5, 2), "X3"=c(0, 1), "X4"=c(1, 0))
#' bm <- as.r4ml.matrix(as.r4ml.frame(df))
#' 
#' # Create a r4ml.als model
#' als <- r4ml.als(data=bm, rank=2, lambda = .1)
#' 
#' }
#' 
#' @seealso \link{predict.r4ml.als}
#' @export
r4ml.als <- function(data, rank, reg.type, lambda, iter.max, tolerance) {
  new("r4ml.als", modelType="factorization", data=data,
      rank=rank, reg.type = reg.type, lambda=lambda, iter.max=iter.max, tolerance=tolerance)
}

setMethod("r4ml.model.validateTrainingParameters", signature="r4ml.als", definition =
  function(model, args) {
    
    logSource <- "r4ml.als"
    
    with(args, {
      .r4ml.checkParameter(logSource, rank, inheritsFrom=c("integer", "numeric"), isOptional=T)
      .r4ml.checkParameter(logSource, reg.type, inheritsFrom=c("character"), isOptional=T)
      .r4ml.checkParameter(logSource, lambda, inheritsFrom=c("integer", "numeric"), isOptional=T)
      .r4ml.checkParameter(logSource, iter.max, inheritsFrom=c("integer", "numeric"), isOptional=T)
      .r4ml.checkParameter(logSource, tolerance, inheritsFrom=c("integer", "numeric"), isOptional=T)
    
      if (!missing(data) && missing(rank)) {
        r4ml.err(logSource, "Both data and rank arguments must be provided.")
      }    
      
      if(!missing(rank) && (rank <= 0 || rank != as.integer(rank))) {
        r4ml.err(logSource, "Parameter rank must be a positive integer number")
      }
      
      if(!missing(reg.type) && !(reg.type == "L2" || reg.type == "wL2")) {
        r4ml.err(logSource, "Parameter reg must be a either L2 or wL2")
      }
      
      if(!missing(iter.max) && (iter.max <= 0 || iter.max != as.integer(iter.max))) {
        r4ml.err(logSource, "Parameter iter.max must be a positive integer")
      }
      
      if(!missing(lambda) && (lambda < 0)) {
        r4ml.err(logSource, "Parameter lambda must be a non negative real number")
      }
      
      if(!missing(tolerance) && (tolerance < 0)) {
        r4ml.err(logSource, "Parameter tolerance must be a non negative real number")
      }
                
      #check if rank is smaller than the dimensions of the data matrix
      if(!missing(data) && (SparkR::nrow(data) < rank || SparkR::ncol(data) < rank)){
        r4ml.err(logSource, "Parameter rank must be smaller than the number of rows and columns of the input matrix")
      }
                
    })
    return(model)
  }
)


setMethod("r4ml.model.buildTrainingArgs", signature="r4ml.als", definition =
  function(model, args) {
    with(args, {
      
      directory <- r4ml.env$WORKSPACE_ROOT("r4ml.ml.model.als")
      
      # configuration and data paths - DML returns errors without the pathing arguments
      leftFactorPath <- directory %++% "/L";
      rightFactorPath <- directory %++% "/R";
      VcopyPath <- directory %++% "/V"; 
      

      dmlPath <- file.path(r4ml.env$SYSML_ALGO_ROOT(), r4ml.env$DML_ALS_DS_SCRIPT)
      dmlArgs <- list(dml = dmlPath, V=data, "L", "Rt", check=TRUE, fmt='CSV')
      
      # if (conjugate_gradient) {
      #   dmlArgs <- list(dml = dmlPath, V=data, "L", "Rt", ibL=leftFactorPath, R=rightFactorPath, M=VcopyPath, check=TRUE, fmt='CSV')
      # }
      
      if (!missing(lambda)) {
        dmlArgs <- c(dmlArgs, lambda=lambda)
      }
      if (!missing(reg.type)) {
        dmlArgs <- c(dmlArgs, reg=reg.type)
      }
      if (!missing(rank)) {
        dmlArgs <- c(dmlArgs, rank=rank)
      }
      if (!missing(iter.max)) {
        dmlArgs <- c(dmlArgs, maxi=iter.max)
      }
      if (!missing(tolerance)) {
        dmlArgs <- c(dmlArgs, thr=tolerance)
      }
      model@dmlArgs <- dmlArgs
      return(model)
    })
  }
)

setMethod("r4ml.model.postTraining", signature = "r4ml.als", definition =
  function (model) {
    model@leftFactor <- model@dmlOuts$sysml.execute$L
    model@rightFactor <- model@dmlOuts$sysml.execute$Rt
    return(model)
  }
)


#' Predict method for Alternating Least Squares
#' 
#' The \code{predict.r4ml.als} function predicts ratings using previously
#' generated factor matrices: L and R.
#' @param data (r4ml.matrix) The input data can be a list of user-ids. In this
#' case top recommendations will be predicted. It can also be a list of
#' (user-id, item-id) pairs. In this case the prediction will be made for each 
#' pair individually. 
#' @param type (character) Equal to "pairs" or "topk"
#' @param k (numeric) The number of top k items. This paramet is applicable only
#' if predictTop = TRUE
#' @param object (r4ml.als) The ALS Model
#' @export
#' @return a \code{r4ml.matrix} which contain a list of triples: {user-id,
#' item-id, rating} if predictTop = FALSE or a list of top recommendations for
#' each user if predictTop = TRUE
#' 
#' @details Factorization based prediction can be used to make recommendations
#' or in general for predictions based on factor matrices L and R.
#' 
#' @examples \dontrun{
#' 
#' # Create a sample dataset: 4 items, 2 users
#' df <- data.frame(X1=c(1, 0), X2=c(5, 2), "X3"=c(0, 1), "X4"=c(1, 0))
#' bm <- as.r4ml.matrix(df)
#' 
#' # Create a r4ml.als model
#' als <- r4ml.als(data=bm, rank=2, lambda = .1)
#' 
#' # Predict ratings for a given input list of pairs (user-id, item-id)
#' dfTest <- data.frame(userIndex=c(1, 1, 2, 2), itemIndex=c(4, 1, 2, 3))
#' bmTest <- as.r4ml.matrix(as.r4ml.frame(dfTest))
#' pred <- predict(als, bmTest)
#' }
#' 
#' @seealso \link{r4ml.als}
#' @export
predict.r4ml.als <- function(object, data, type, k){
  
  logSource <- "predict.r4ml.als"
  
  type <- ifelse(missing(type), r4ml.env$ALS_PAIR, type);
  modelDir <- object@modelPath;
  directory <- r4ml.env$WORKSPACE_ROOT("r4ml.ml.model.als")
  
  
  .r4ml.checkParameter(logSource, data, inheritsFrom="r4ml.matrix", isOptional=F);
  .r4ml.checkParameter(logSource, directory, inheritsFrom = "character")
  .r4ml.checkParameter(logSource, type, inheritsFrom="character", isOptional=T);
  .r4ml.checkParameter(logSource, k, inheritsFrom=c("integer","numeric"), isOptional=T);
  
  if (!(type %in% c(r4ml.env$ALS_PAIR, r4ml.env$ALS_TOPK))){
    r4ml.err(logSource, "Type must have values pair or topk ");
  }
  
  
  k <- ifelse(missing(k), 5, k);
  
  #check that data has 2 columns
  if (type == r4ml.env$ALS_PAIR & SparkR::ncol(data) != 2){
    r4ml.err(logSource, "Test data has to have 2 columns: (user-id, item-id) pairs");
  }else if(type == r4ml.env$ALS_TOPK & SparkR::ncol(data) != 1){
    r4ml.err(logSource, "Test data for top predictions has to have 1 column: the list of user ids");
  }

  #verify that all pairs of user-id and password exist in factor matrices
  #TODO In future, don't store the entire input data - just store the number of rows an columns.
  V <- object@dmlArgs$V
  n <- SparkR::nrow(V);
  m <- SparkR::ncol(V);
  vp_colnames <- SparkR::columns(V)
  
  dmlScript <- file.path(r4ml.env$SYSML_ALGO_ROOT(), r4ml.env$DML_ALS_PREDICT_SCRIPT);
  
  # TODO: Enable when we add topK script
  # if (type == r4ml.env$ALS_TOPK){
  #   dmlScript <- file.path(r4ml.env$SYSML_ALGO_ROOT(), r4ml.env$DML_ALS_TOP_PREDICT_SCRIPT)
  #   data_colnames <- c("user")
  # }

  args = list(X = data, dml=dmlScript, L=object@dmlOuts$sysml.execute$L, 
              R=object@dmlOuts$sysml.execute$Rt, Y=directory %++% "/prediction" %++% r4ml.env$FBP_SUFFIX,
              "V_prime");
  
  if (type == r4ml.env$ALS_PAIR){
    args <- c(args, Vrows=n);
    args <- c(args, Vcols=m);
    args <- c(args, fmt = "TEXT");
  }else{
    args <- c(args, V=V@dataPath);
    args <- c(args, K=k);
    args <- c(args, fmt = "CSV");
  }
  
  # execute factorization based predict dml script
  dmlErr <- do.call("sysml.execute", args);
  
  # access the output
  Vp <- dmlErr$V_prime
  SparkR::colnames(Vp) <- vp_colnames
  
  return(Vp)
}
